import numpy as np
import heapq
from typing import List, Tuple, Dict
# --------------------------
# 5. Maze Solving with A* Algorithm
# --------------------------
def solve_maze_a_star(maze: np.ndarray, start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
    """
    Solve a maze using A* algorithm.
    
    Args:
        maze: Maze grid generated by generate_maze_dfs()
        start: (y, x) coordinates of the start point
        end: (y, x) coordinates of the end point
    
    Returns:
        List[Tuple[int, int]]: Path from start to end (empty list if no path exists)
    """
    height, width = maze.shape
    
    # Check if start and end are valid paths
    if maze[start[0], start[1]] != 0 or maze[end[0], end[1]] != 0:
        return []
    
    # 4 possible movement directions (up, down, left, right)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # Heuristic function: Manhattan distance to end point
    def heuristic(y: int, x: int) -> int:
        return abs(y - end[0]) + abs(x - end[1])
    
    # Priority queue: (f_score, g_score, y, x)
    open_heap = []
    heapq.heappush(open_heap, (heuristic(start[0], start[1]), 0, start[0], start[1]))
    
    # Dictionary to track path history
    came_from: Dict[Tuple[int, int], Tuple[int, int]] = {}
    
    # g_score: cost from start to current position
    g_score = np.full((height, width), np.inf)
    g_score[start[0], start[1]] = 0
    
    # f_score: g_score + heuristic (estimated total cost)
    f_score = np.full((height, width), np.inf)
    f_score[start[0], start[1]] = heuristic(start[0], start[1])
    
    # Set of processed nodes
    closed_set = set()
    
    while open_heap:
        # Get node with lowest f_score
        current_f, current_g, current_y, current_x = heapq.heappop(open_heap)
        
        # Check if we've reached the end
        if (current_y, current_x) == end:
            # Reconstruct path
            path = []
            current = (current_y, current_x)
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]  # Reverse to get start -> end order
        
        # Add to processed set
        closed_set.add((current_y, current_x))
        
        # Explore neighbors
        for dy, dx in directions:
            next_y = current_y + dy
            next_x = current_x + dx
            
            # Check if neighbor is within bounds and is a path
            if 0 <= next_y < height and 0 <= next_x < width and maze[next_y, next_x] == 0:
                # Skip if already processed
                if (next_y, next_x) in closed_set:
                    continue
                
                # Tentative cost to reach neighbor
                tentative_g = current_g + 1
                
                # If this path is better than previously known
                if tentative_g < g_score[next_y, next_x]:
                    # Update path tracking
                    came_from[(next_y, next_x)] = (current_y, current_x)
                    g_score[next_y, next_x] = tentative_g
                    f_score[next_y, next_x] = tentative_g + heuristic(next_y, next_x)
                    
                    # Add to priority queue
                    heapq.heappush(open_heap, (f_score[next_y, next_x], tentative_g, next_y, next_x))
    
    # No path found
    return []
