import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import random
from typing import List, Tuple
# --------------------------
# 2. Maze Solving with DFS
# --------------------------
def solve_maze_dfs(maze: np.ndarray, start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
    """
    Solve a maze using Depth-First Search (DFS) algorithm.
    
    Args:
        maze: Maze grid generated by generate_maze_dfs()
        start: (y, x) coordinates of the start point
        end: (y, x) coordinates of the end point
    
    Returns:
        List[Tuple[int, int]]: Path from start to end (empty list if no path exists)
    """
    # Get maze dimensions
    height, width = maze.shape
    # Visited matrix to avoid revisiting cells
    visited = np.zeros((height, width), dtype=bool)
    # Stack for DFS: stores (current_y, current_x, path_so_far)
    dfs_stack = [(start[0], start[1], [start])]
    # Mark start as visited
    visited[start[0], start[1]] = True
    # Define 4 possible movement directions (up, down, left, right)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Step 1 for adjacent cells
    
    while dfs_stack:
        current_y, current_x, current_path = dfs_stack.pop()
        
        # Check if current position is the end
        if (current_y, current_x) == end:
            return current_path  # Return the path if end is reached
        
        # Explore all directions
        for dy, dx in directions:
            next_y = current_y + dy
            next_x = current_x + dx
            # Check if next cell is within bounds, is a path (0), and not visited
            if (0 <= next_y < height) and (0 <= next_x < width):
                if (maze[next_y, next_x] == 0) and (not visited[next_y, next_x]):
                    visited[next_y, next_x] = True
                    # Create new path by appending next cell
                    new_path = current_path.copy()
                    new_path.append((next_y, next_x))
                    # Add to stack for further exploration
                    dfs_stack.append((next_y, next_x, new_path))
    
    # Return empty list if no path exists (should not happen for DFS-generated mazes)
    return []