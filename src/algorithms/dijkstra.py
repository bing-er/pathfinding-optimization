# --------------------------
# 6. Maze Solving with Dijkstra's Algorithm
# --------------------------
def solve_maze_dijkstra(maze: np.ndarray, start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
    """
    Solve a maze using Dijkstra's algorithm.
    
    Args:
        maze: Maze grid generated by generate_maze_dfs()
        start: (y, x) coordinates of the start point
        end: (y, x) coordinates of the end point
    
    Returns:
        List[Tuple[int, int]]: Path from start to end (empty list if no path exists)
    """
    height, width = maze.shape
    
    # Check if start and end are valid paths
    if maze[start[0], start[1]] != 0 or maze[end[0], end[1]] != 0:
        return []
    
    # 4 possible movement directions (up, down, left, right)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # Priority queue: (distance, y, x)
    priority_queue = []
    heapq.heappush(priority_queue, (0, start[0], start[1]))
    
    # Dictionary to track path history
    came_from: Dict[Tuple[int, int], Tuple[int, int]] = {}
    
    # Distance from start to each position (infinity initially)
    distance = np.full((height, width), np.inf)
    distance[start[0], start[1]] = 0
    
    # Set of processed nodes
    processed = set()
    
    while priority_queue:
        # Get node with smallest known distance
        current_dist, current_y, current_x = heapq.heappop(priority_queue)
        
        # Check if we've reached the end
        if (current_y, current_x) == end:
            # Reconstruct path
            path = []
            current = (current_y, current_x)
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]  # Reverse to get start -> end order
        
        # Skip if already processed
        if (current_y, current_x) in processed:
            continue
        
        # Mark as processed
        processed.add((current_y, current_x))
        
        # Explore neighbors
        for dy, dx in directions:
            next_y = current_y + dy
            next_x = current_x + dx
            
            # Check if neighbor is within bounds and is a path
            if 0 <= next_y < height and 0 <= next_x < width and maze[next_y, next_x] == 0:
                # Calculate tentative distance (each step has cost 1)
                tentative_dist = current_dist + 1
                
                # If this path is better than previously known
                if tentative_dist < distance[next_y, next_x]:
                    came_from[(next_y, next_x)] = (current_y, current_x)
                    distance[next_y, next_x] = tentative_dist
                    heapq.heappush(priority_queue, (tentative_dist, next_y, next_x))
    
    # No path found
    return []
