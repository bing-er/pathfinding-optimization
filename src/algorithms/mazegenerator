import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import random
from typing import List, Tuple

# --------------------------
# 1. Maze Generation with DFS
# --------------------------
def generate_maze_dfs(width: int, height: int) -> np.ndarray:
    """
    Generate a random maze using Depth-First Search (DFS) algorithm.
    
    Args:
        width: Number of columns in the maze (x-axis)
        height: Number of rows in the maze (y-axis)
    
    Returns:
        np.ndarray: Maze grid where:
                    - 1 = Wall
                    - 0 = Path
    """
    # Initialize maze with all walls (1). Use odd indices for paths to ensure wall borders.
    maze = np.ones((height, width), dtype=int)
    # Stack to track DFS traversal (stores (y, x) coordinates)
    dfs_stack = []
    # Starting point (must be odd indices to avoid border walls)
    start_y, start_x = 1, 1
    # Mark start as path (0) and add to stack
    maze[start_y, start_x] = 0
    dfs_stack.append((start_y, start_x))
    
    # Define 4 possible movement directions (up, down, left, right)
    directions = [(-2, 0), (2, 0), (0, -2), (0, 2)]  # Step 2 to skip wall between cells
    
    while dfs_stack:
        # Current position (LIFO: Last-In-First-Out for DFS)
        current_y, current_x = dfs_stack.pop()
        # Shuffle directions to ensure random maze generation
        random.shuffle(directions)
        
        for dy, dx in directions:
            # Calculate next cell position (skip wall)
            next_y = current_y + dy
            next_x = current_x + dx
            # Check if next cell is within bounds and still a wall (1)
            if (1 <= next_y < height - 1) and (1 <= next_x < width - 1) and (maze[next_y, next_x] == 1):
                # Carve path: mark next cell as path (0) and remove the wall between current and next
                maze[next_y, next_x] = 0
                maze[current_y + dy//2, current_x + dx//2] = 0  # Remove middle wall
                # Add next cell to DFS stack for further traversal
                dfs_stack.append((next_y, next_x))
    
    # Set fixed start (bottom-left) and end (top-right) points (ensure they are paths)
    maze[1, 1] = 0  # Start (y=1, x=1)
    maze[height-2, width-2] = 0  # End (y=height-2, x=width-2)
    
    return maze
